#ifndef _CTL_PARSER_MAKERS_HH_
#define _CTL_PARSER_MAKERS_HH_

#include <iostream>

#include <boost/variant.hpp>

#include "ctl/formula.hh"

namespace ctl {

////////////////////////////////////////////////////////////////////

formula
make_property();

////////////////////////////////////////////////////////////////////

formula
make_constant(bool b);

////////////////////////////////////////////////////////////////////

/// Visitor to flatten operands of the same logical operator.
/// i.e. "A and B and C" => "and(A,B,C)".
template< typename LogicalOperator >
struct flatten_visitor;

////////////////////////////////////////////////////////////////////

/// Construct an AND logical operator.
/// i.e. "A and B".
formula
make_and( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

/// Construct an OR logical operator.
/// i.e. "A or B".
formula
make_or( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

/// Construct an NOT logical operator.
/// i.e. "not A".
formula
make_not( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct a XOR logical operator.
/// i.e. "A xor B".
formula
make_xor( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

formula
make_implies( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

formula
make_eq( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

/// Construct an Always Finally temporal operator.
/// i.e. "AF(P)".
formula
make_AF( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct an Exists Finally temporal operator.
/// i.e. "EF(P)".
formula
make_EF( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct an Always Globally temporal operator.
/// i.e. "AG(P)".
formula
make_AG( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct an Exists Globally temporal operator.
/// i.e. "EG(P)".
formula
make_EG( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct an Always Next temporal operator.
/// i.e. "AX(P)".
formula
make_AX( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct an Exists Next temporal operator.
/// i.e. "EX(P)".
formula
make_EX( const formula& f );

////////////////////////////////////////////////////////////////////

/// Construct an Always Until temporal operator.
/// i.e. "A(P U Q)".
formula
make_AU( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

/// Construct an Exists Until temporal operator.
/// i.e. "E(P U Q)".
formula
make_EU( const formula& lhs , const formula& rhs );

////////////////////////////////////////////////////////////////////

} // namespace ctl

#endif // _CTL_PARSER_MAKERS_HH_
